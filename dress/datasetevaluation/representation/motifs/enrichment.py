from abc import abstractmethod
import os
import subprocess
from typing import Union
import pandas as pd
from dress.datasetevaluation.representation.motifs.utils import _dataset_to_fasta
from dress.datasetgeneration.dataset import Dataset
from dress.datasetgeneration.logger import setup_logger
from dress.datasetgeneration.os_utils import assign_proper_basename
from scipy.stats import fisher_exact
from statsmodels.stats.multitest import multipletests
from matplotlib import pyplot as plt
import seaborn as sns


class MotifEnrichment:
    def __init__(
        self, df: Union[Dataset, pd.DataFrame], specific_basename: str = None, **kwargs
    ):
        """
        Perform motif enrichment between two sequence groups. If only
        one group is given, control sequences will be created by shuffling
        sequences of the first group.

        Args:
            df Union[Dataset, pd.DataFrame]: Dataframe with sequence IDs (in rows)
        and motif counts (in columns). A `group` column must
        exist in the data defining the groups to be compared
            specific_basename (str): Specific basename to add to output.
        """

        if "logger" in kwargs:
            self.logger = kwargs["logger"]
        else:
            self.logger = setup_logger(level=0)

        if isinstance(df, Dataset):
            df = df.data

        assert "group" in df.columns, "A 'group' column must exist in the data"
        if df.group.nunique() == 1:
            self.logger.warning(
                "Only 1 group found. Control sequences will be generated by shuffling the dataset"
            )

        for c in ["Score", "Delta_score"]:
            if c in df.columns:
                df.drop(columns=c, inplace=True)

        self.seqs = df[["Seq_id", "Sequence", "group"]]
        self.outdir = os.path.join(kwargs.get("outdir", "output"), "motifs/enrichment")
        os.makedirs(self.outdir, exist_ok=True)
        self.outbasename = assign_proper_basename(kwargs.get("outbasename"))
        self.specific_basename = assign_proper_basename(specific_basename)

    @abstractmethod
    def visualize(self): ...


class StremeEnrichment(MotifEnrichment):
    def __init__(self, df: pd.DataFrame, specific_basename: str = None, **kwargs):
        super().__init__(df, specific_basename, **kwargs)

        if hasattr(self, "seqs"):
            self.results = self._run()

    def _run(self) -> pd.DataFrame:
        """
        Run STREME from MEME suite
        """
        streme_outdir = self.outdir + "/streme"
        os.makedirs(streme_outdir, exist_ok=True)

        streme_cmd = [
            "streme",
            "--objfun",
            "de",
           # "--no-pgc",
            "--rna",
            "--hofract",
            "0.1",
            "-minw",
            "5",
            "-maxw",
            "12",
            "--order",
            "2",
            "--thresh",
            "0.01",
            "--evalue",
            "--patience",
            "5",
            "--oc",
            streme_outdir,
        ]

        if self.seqs.group.nunique() == 2:
            fasta_files = _dataset_to_fasta(
                self.seqs, groupby_col="group", outdir=streme_outdir
            )
        else:
            fasta_files = [_dataset_to_fasta(self.seqs, outdir=streme_outdir)]
        
        for i, f in enumerate(fasta_files):
            streme_cmd += ["--p", f] if i == 0 else ["--n", f]

        self.logger.info("Running STREME ..")
        self.logger.debug(f"Command to run STREME: {' '.join(streme_cmd)}")
        _p = subprocess.run(
            streme_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)
        if _p.returncode != 0:
            self.logger.error(
                f"STREME failed with error: {_p.stderr.decode()}")

    def visualize(self):
        """
        Visualize motif enrichment results

        Args:
            df (pd.DataFrame): Dataframe with motif enrichment results
        """
        pass
        # if not hasattr(self, "results"):
        #     self.logger.warning("No motif enrichment results found for visualization.")
        #     return

        # df = self.results.copy()

        # # Sort by average corrected p-value
        # df_avg = (
        #     df.groupby("RBP")["p_value_corrected"]
        #     .mean()
        #     .reset_index(name="avg_p_value_corrected")
        # )
        # df = df.merge(df_avg, on="RBP")
        # df = df.sort_values("avg_p_value_corrected", ascending=True)

        # # Plot just top 50 motifs

        # if df["RBP"].nunique() > 50:
        #     self.logger.info("INFO", "Plotting just the top 50 motifs")

        #     top_50_motifs = df.RBP.drop_duplicates(keep="first").tolist()
        #     df = df[df.RBP.isin(top_50_motifs[:50])]

        # _, ax = plt.subplots(figsize=(4, 7))

        # # Create stripplot
        # sns.stripplot(
        #     data=df,
        #     x="p_value_corrected",
        #     y="RBP",
        #     dodge=True,
        #     jitter=True,
        #     palette="Blues",
        #     size=6,
        #     alpha=0.7,
        #     hue=df["p_value_corrected"] < 0.05,
        #     hue_order=[True, False],
        #     legend=False,
        #     linewidth=1,
        #     edgecolor="black",
        #     clip_on=False,
        #     ax=ax,
        # )

        # ax.axvline(x=0.05, color="black", linestyle="--")
        # ax.text(0.05, 1.01, "0.05", transform=ax.get_xaxis_transform(), fontsize=8)

        # # ax.set_xlim([0, 0.2])
        # ax.set_yticks(ax.get_yticks())
        # ax.set_yticklabels(ax.get_yticklabels(), va="center", fontsize=8)
        # ax.set_xlabel("Corrected p-value")
        # ax.set_ylabel("")

        # # handles, _ = ax.get_legend_handles_labels()
        # # ax.legend(handles, ["Significant (p < 0.05)", "Non-significant"], loc="lower right")

        # plt.savefig(
        #     os.path.join(
        #         self.outdir,
        #         f"{self.outbasename}{self.specific_basename}fisher_enrichment.pdf",
        #     ),
        #     bbox_inches="tight",
        # )
        # plt.close()
